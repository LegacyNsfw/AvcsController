Low-pass filter on target angle?
	Maybe just for a few seconds after coming out of idle or calibration mode

Revise older classes to use interface-style class declarations
	ScreenNavigator
	Mode
	PlxProcessor
	InterruptHandlers
	CrankState ?
	ExchaustCamState ?

Paint a second timing mark on the cam pulley
	Would allow doing the feedback math & solenoid DC changes twice as often
	Only paint 1/8th of the pulley for the new mark.
	CrankState must distinguish between long and short marks
	ExhaustCamState would calculate angle during Pulse2 ISRs, based on time since short crank mark.

Add MAP sensor
	Will allow reduced retard for lower overlap at high boost
	Not sure how useful that would be, though.


if ((rpm < minimum) || (mode.GetMode() != Mode::Running))
{
	deadline = millis() + Ramp::DelayTime;
}

targetAngle = table->GetValue(RPM);
targetAngle = ramp->GetValue(targetAngle, deadline);

float Ramp::GetValue(float target, unsigned long deadline)
{
	long millis = millis();
	if (millis > deadline)
	{
		return target;
	}

	if (millis < deadline - DelayTime)
	{
		return 0;
	}	

	float startTime = deadline - DelayTime;
	float elapsedTime = millis - startTime;
	float fraction = elapsedTime / DelayTime;
	return target * fraction;
}